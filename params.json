{"name":"Cake Pattern in JDK8","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"Evolve beyond dependency injection","google":"","body":"Spring has recently released support for Scala (see http://blog.springsource.org/2012/12/10/introducing-spring-scala/). This of course can't go unheeded and there is only one correct way to counter this: Outlining the Cake Pattern for Java ;-)\r\n\r\nIn order to create unnecessary confusion I try to illustrate the principles by implementing an extremely simple cake database with web frontend. You'll find the repository for this at: https://github.com/thoraage/cake-db-jdk8\r\n\r\nIn order to use the code in this project now (7. January 2013) you will need to download the lambda version of JDK8. You'll find it here: http://jdk8.java.net/lambda/\r\n\r\n## What is the Cake Pattern?\r\n\r\nThe Cake Pattern is dependency injection's type safe and annotation/xml-free cousin. It works by creating traits for each module. Traits in Scala are basically interfaces with state and methods. These traits can be layered on top of each other into a concrete class or object; a cake. You can combine these modules in any way you'd like to create different cakes according to different demands.\r\n\r\n## Why?\r\n\r\nJava developers have been toiling away writing XML-files and flimsy annotations for years. It's time that they get a taste of the goodness that static typing were supposed to give them.\r\n\r\n## How?\r\n\r\nJDK8 includes among other handsome features something called virtual extension methods. This opens for adding code into interfaces. If you know Scala you can think of it as Scala's traits on sedatives. However, since you can add as many interfaces as you like you now have a limited multiple inheritance. Here is an example of how such an interface might look:\r\n\r\n```java\r\npublic interface AnInterface {\r\n    default void sayHello() {\r\n        System.out.println(\"Hello\");\r\n    }\r\n}\r\n```\r\n\r\n## Problem with State\r\n\r\nSince you still can't have state in interfaces I've implemented that through the _SingletonModule_ interface and the _SingletonModuleImpl_ class. This is not optimal as the class will devour our potential \"real\" inheritance. However, I've not found any competing use for it; yet. The _SingletonModule_ looks like this:\r\n\r\n```java\r\npublic interface SingletonModule {\r\n    interface Singleton {\r\n        <M extends SingletonModule, T> T get(Class<M> clazz);\r\n        <M extends SingletonModule, T> void put(Class<M> clazz, T t);\r\n    }\r\n    void initialize();\r\n    Singleton getSingleton();\r\n}\r\n```\r\n\r\nI've created an initialisation step here so that I don't have to worry about thread safety of lazy singletons. It also asserts fast failure. You can see how we put and get singletons in the _CakeJdbcDbModule_:\r\n\r\n```java\r\npublic interface CakeJdbcDbModule extends DbModule, DbConfigurationModule, SingletonModule {\r\n    class JdbcDb implements Db {\r\n        ...\r\n    }\r\n    @Override\r\n    default void initialize() {\r\n        getSingleton().put(CakeJdbcDbModule.class, new JdbcDb(this));\r\n    }\r\n    @Override\r\n    default Db getDb() {\r\n        return getSingleton().get(CakeJdbcDbModule.class);\r\n    }\r\n}\r\n```\r\n\r\nSadly the initialisation methods will have to be initialised from the top for each module with initialisation needs.\r\n\r\n## The Stack\r\n\r\nIf we start from the top it looks like this:\r\n\r\n```java\r\nclass CakeStack extends SingletonModuleImpl implements CakeConfigurationModule, CakeJdbcDbModule, CakePageHandlerModule, JettyWebHandlerModule {\r\n    @Override\r\n    public void initialize() {\r\n        CakeJdbcDbModule.super.initialize();\r\n        JettyWebHandlerModule.super.initialize();\r\n    }\r\n}\r\n```\r\n\r\nThis represent a complete runnable stack. Here you can also observe the initialisation in action. Let us concentrate on the most important modules:\r\n\r\n* _CakeConfigurationModule_ - Contains configuration parameters\r\n* _CakeJdbcDbModule_ - Provides access to the database\r\n* _CakePageHandlerModule_ - Handles page requests\r\n* _JettyWebHandlerModule_ - Starts a web server and directs requests to the page handler\r\n\r\nAll these modules have to be added in the order of their dependencies. _JettyWebHandlerModule_ last since it depends on _CakePageHandlerModule_ and _CakeConfigurationModule_. _CakeConfigurationModule_ first as it is not dependent on anything.\r\n\r\nTo start using this stack we need only instantiate it and start the _WebHandler_:\r\n\r\n```java\r\nnew CakeStack().getWebHandler().start();\r\n```\r\n\r\nThe _CakeStack_ refer only concrete implementations of all the modules we need and we could change easily exchange the implementations when needed. For example by inserting a _CakeMongoDbModule_ instead of the _CakeJdbcDbModule_. This will in no way affect how the _CakePageHandlerModule_ get cakes from the database by calling 'module.getDb().getCakes()'.\r\n\r\n## Creating a Module\r\n\r\nEach module is implementing a method that return the needed module implementation. Default methods on the interfaces enable us to add as many modules as we please. Each module on the other hand is implemented as generic as possible:\r\n\r\n```java\r\npublic interface CakePageHandlerModule extends PageHandlerModule, DbModule {\r\n    class CakePageHandler implements PageHandler {\r\n        ...\r\n    }\r\n    @Override\r\n    default PageHandler getPageHandler() {\r\n        return new CakePageHandler(this);\r\n    }\r\n}\r\n```\r\n\r\nIn this example we extend the _PageHandlerModule_ and the _DbModule_. The _PageHandlerModule_ is the responsibility of this module so we implement that. The _DbModule_ however, we just request and leave for someone else to provide an implementation for us. This makes it simple to have one implementation for test and a completely different for production.\r\n\r\nI have modelled _CakePageHandler_ as a nested class of the _CakePageHandlerModule_-interface. Notice however that I need to pass the module in as a constructor argument. A nested class B in a class A will have access to A through 'A.this'. A nested class in an interface on the other hand is more akin to a static nested class and does not really have a relation to its outer class. In order to underline the connection between the entities I've chosen to keep the module implementation inside the module interface anyway.\r\n\r\n## Conclusion\r\n\r\nAll-in-all I'm quite happy about how this experiment unfolded. It has some drawbacks compared to applying it in Scala. Particularly the way Scala traits hold state and how nested classes in traits can directly access the trait. That aside, I believe it presents a compelling way to build an application and it would be really interesting to see how this would play out in a real project."}